# Requests - это внешний модуль Python, который используют для отправки всех видов HTTP-запросов.
# Данный модуль включает в себя  множеством функций, начиная от передачи параметров в URL-адресах
# до отправки пользовательских заголовков и проверки SSL

import requests # Для начала импортируем данный модуль

# HTTP методы: GET и POST определяют, какие действия будут выполнены при создании HTTP запроса и являются самыми популярными методами.
# Также существуют и другие методы, о них будет рассказано позже
# Метод GET указывает на то, что происходит попытка извлечь данные из определенного ресурса
# Для того, чтобы выполнить запрос GET, используется requests.get().
# Рассмотрим пример:
requests.get('https://api.github.com')

# Итак первый запрос выполнен. Теперь получим ответ на данный запрос, с помощью объекта Response.
# Response - это объект для анализа результатов запроса

response = requests.get('https://api.github.com')
print (response)

# get() захватывает значение, что является частью объекта  Response и помещает в переменную.
# Теперь данные хранящиеся в переменной мы можем изучить
# Самыми первыми данными, которые будут получены через Response, будут коды состояния,
# которые сообщают о статусе запроса. Пример: если статус 200 OK значит, что запрос выполнен,
# а  404 NOT FOUND - ресурс не найден
# Узнаем код состояния, для этого используем status_code

print(response.status_code)

# мы получаем значение 200 значит запрос выполнен успешно

# дальше запишем следующие строки кода.
if response.status_code == 200:
    print('запрос выполнен')
elif response.status_code == 404:
    print('Ресурс не был найден')

# Иногда бывает, что полученную информацию необходимо использовать.
# Если с сервера будет получен код состояния 200, тогда программа выведет значение "запрос выполнен".
# Однако, если от сервера поступит код 404, тогда программа выведет значение "Ресурс не был найден".


# requests может значительно упростить весь процесс.
# Если использовать Response в условных конструкциях, то при получении кода состояния в промежутке от
# 200 до 400, будет выведено значение True. В противном случае отобразится значение False.
# Последний пример можно упростить при помощи использования оператора if.

if response:
    print('запрос выполнен')
else:
    print('Ресурс не был найден')

# Стоит иметь в виду, что данный способ не проверяет, имеет ли статусный код точное значение 200.
# Причина заключается в том, что другие коды в промежутке от 200 до 400, например,
# 204 NO CONTENT и 304 NOT MODIFIED, также считаются успешными в случае,
# если они могут предоставить действительный ответ.
# Код состояния 204 - значит ответ получен, но в полученном объекте нет содержимого.
# Требуется изучить код состояния и в случае необходимости произвести необходимые поправки,
# которые будут зависеть от значения полученного кода.

# если при использовании оператора if вы не хотите проверять код состояния,
# можно расширить диапазон исключений для неудачных результатов запроса.
# Это можно сделать при помощи использования .raise_for_status()

from requests.exceptions import HTTPError
for url in ['https://api.github.com', 'https://api.github.com/invalid']:
    try:
        response = requests.get(url)
 
        # если ответ успешен, исключения задействованы не будут
        response.raise_for_status()
    except HTTPError as http_err:
        print(f'HTTP error occurred: {http_err}')  # Python 3.6
    except Exception as err:
        print(f'Other error occurred: {err}')  # Python 3.6
    else:
        print('Отлично')

# В примере В случае вызова исключений через .raise_for_status() к некоторым кодам состояния применяется HTTPError.

# Информация, находящаяся в теле сообщения и полученная при запросе GET,называется пейлоад
# Используя атрибуты и методы библиотеки Response, можно получить пейлоад в различных форматах.

# Примеры:
# Мы можем получить содержимое запроса в байтах, для этого необходимо использовать поле "content":

print(response.content)

# Иногда необходимо конвертировать полученную информацию в строку в кодировке UTF-8.
# Для этого есть поле "text":

print(response.text)

# По умолчанию requests попытается узнать текущую кодировку, ориентируясь по заголовкам HTTP.
# Указать необходимую кодировку можно при помощи поля "encoding":

response.encoding = 'utf-8'
response.text

# Если присмотреться к ответу, можно заметить, что его содержимое является сериализированным JSON контентом.
# Воспользовавшись словарем, можно взять полученные из .text строки str и провести с ними обратную
# сериализацию при помощи использования json.loads().
# Есть и более простой способ, который требует применения метода .json():

print(response.json())

# Метод вернёт словрь, а это удобно


# Коды состояния и тело сообщения предоставляют огромный диапазон возможностей.
# Однако, для их оптимального использования требуется изучить метаданные и заголовки HTTP.
# HTTP заголовки ответов на запрос могут предоставить определенную полезную информацию.
# Это может быть тип содержимого ответного пейлоада, а также ограничение по времени для кеширования ответа.
# Для просмотра HTTP заголовков загляните в атрибут "headers":

print(response.headers)

# Поле "headers" возвращает словарь, что позволяет получить доступ к значению заголовка HTTP по ключу.
# Например, для просмотра типа содержимого ответного пейлоада, требуется использовать Content-Type.

print(response.headers['Content-Type'])

#  Специфика HTTP предполагает, что заголовки не чувствительны к регистру
# При использовании ключей 'content-type' и 'Content-Type' результат будет получен один и тот же

# Наиболее простым способом настроить запрос GET является передача значений через параметры строки запроса в URL.
# При использовании метода get(), данные передаются в params.
# Пример:
# для того, чтобы посмотреть на библиотеку requests можно использовать Search API на GitHub.


# Поиск местонахождения для запросов на GitHub
response = requests.get(
    'https://api.github.com/search/repositories',
    params={'q': 'requests+language:python'},
)
 # Анализ некоторых атрибутов местонахождения запросов
json_response = response.json()
repository = json_response['items'][0]
print(f'Repository name: {repository["name"]}')  
print(f'Repository description: {repository["description"]}')  



# Передавая словарь {'q': 'requests+language:python'} в параметр params, который является частью .get(),
# можно изменить ответ, что был получен при использовании Search API.

# Помими GET, существуют и другие методы:  POST, PUT, DELETE, HEAD, PATCH и OPTIONS.

requests.post('https://httpbin.org/post', data={'key':'value'})
requests.put('https://httpbin.org/put', data={'key':'value'})
requests.delete('https://httpbin.org/delete')
requests.head('https://httpbin.org/get')
requests.patch('https://httpbin.org/patch', data={'key':'value'})
requests.options('https://httpbin.org/get')

# Каждая функция создает запрос к httpbin сервису, используя при этом ответный HTTP метод.
# Результат каждого метода можно изучить способом, который был использован в предыдущих примерах.

response = requests.head('https://httpbin.org/get')
response.headers['Content-Type']
response = requests.delete('https://httpbin.org/delete')
json_response = response.json()
json_response['args']

# При использовании каждого из данных методов в Response могут быть возвращены:
# заголовки, тело запроса, коды состояния и многие другие аспекты. 


# В соответствии со спецификацией HTTP запросы POST, PUT и PATCH передают информацию через тело сообщения,
# A не через параметры строки запроса. Используя requests, можно передать данные в параметр data.
# В свою очередь data использует словарь, список кортежей, байтов или объект файла.
# Это особенно важно, так как может возникнуть необходимость адаптации отправляемых с запросом данных
# в соответствии с определенными параметрами сервера.
# К примеру, если тип содержимого запроса application/x-www-form-urlencoded, можно отправить данные формы в виде словаря.

requests.post('https://httpbin.org/post', data={'key':'value'})

# При составлении запроса стоит иметь в виду, что перед его фактической отправкой на целевой сервер
# библиотека requests выполняет определенную подготовку.
# Подготовка запроса включает в себя такие вещи, как проверка заголовков и сериализация содержимого JSON.

# Если открыть .request, можно просмотреть PreparedRequest.
response = requests.post('https://httpbin.org/post', json={'key':'value'})
response.request.headers['Content-Type']
response.request.url
response.request.body

# Проверка PreparedRequest открывает доступ ко всей информации о выполняемом запросе.
# Это может быть пейлоад, URL, заголовки, аутентификация и многое другое.


# Елси данные которые необходимо отправить являются конфедециальными мы хотим быть уверены в безопасности
#  Вы общаетесь с защищенными сайтами через HTTP, устанавливая зашифрованное соединение с использованием SSL,
# что означает, что проверка SSL сертификата целевого сервера имеет решающее значение.
# Однако requests по умолчанию все делает сам.





